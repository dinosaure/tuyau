<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Make (tuyau.Tuyau.Make)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../../index.html">tuyau</a> &#x00BB; <a href="../index.html">Tuyau</a> &#x00BB; Make</nav><h1>Module <code>Tuyau.Make</code></h1><nav class="toc"><ul><li><a href="#input-&amp;-output.">Input &amp; Output.</a></li><li><a href="#scheduling.">Scheduling.</a></li><li><a href="#registration.">Registration.</a></li><li><a href="#tuyau-as-a-client."><code>Tuyau</code> as a client.</a></li><li><a href="#tuyau-as-a-server."><code>Tuyau</code> as a server.</a></li></ul></nav></header><h3 class="heading">Parameters</h3><ul><li><code><a href="argument-1-Scheduler/index.html">Scheduler</a> : <a href="../Sigs/index.html#module-type-SCHEDULER">Sigs.SCHEDULER</a></code></li><li><code><a href="argument-2-Input/index.html">Input</a> : <a href="../Sigs/index.html#module-type-SINGLETON">Sigs.SINGLETON</a></code></li><li><code><a href="argument-3-Output/index.html">Output</a> : <a href="../Sigs/index.html#module-type-SINGLETON">Sigs.SINGLETON</a></code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-input"><a href="#type-input" class="anchor"></a><code><span class="keyword">type</span> input</code><code> = <a href="argument-2-Input/index.html#type-t">Input.t</a></code></dt><dd><p>The type of the <i>input</i>. A flow is able to <i>send</i> a <i>payload</i>. The type of the <i>payload</i> is <code>input</code>.</p></dd></dl><dl><dt class="spec type" id="type-output"><a href="#type-output" class="anchor"></a><code><span class="keyword">type</span> output</code><code> = <a href="argument-3-Output/index.html#type-t">Output.t</a></code></dt><dd><p>The type of the <i>output</i>. A flow is able to <i>receive</i> a <i>payload</i>. The type of the <i>payload</i> is <code>output</code>.</p></dd></dl><section><header><h4 id="input-&amp;-output."><a href="#input-&amp;-output." class="anchor"></a>Input &amp; Output.</h4><p>Type of input can differ to type of output to have the ability to define capabilities on them such as the <i>read</i> capability or the <i>write</i> capability. A <i>caml</i> example looks like:</p><pre><code class="ml">type input = bytes
type output = string</code></pre></header><dl><dt class="spec type" id="type-s"><a href="#type-s" class="anchor"></a><code><span class="keyword">type</span> <span>+'a s</span></code><code> = <span><span class="type-var">'a</span> <a href="argument-1-Scheduler/index.html#type-t">Scheduler.t</a></span></code></dt><dd><p>The type of <i>scheduler</i>. <code>Tuyau</code> is able to call some <i>syscall</i> which can be wrap in a <i>monad</i> such as LWT or ASYNC. The core <code>Tuyau</code> library is abstracted over that.</p></dd></dl></section><section><header><h4 id="scheduling."><a href="#scheduling." class="anchor"></a>Scheduling.</h4><p><code>Tuyau</code> does not do the choice about LWT or ASYNC (or UNIX). However, it should be able to call any <i>syscall</i> (like <code>Unix.connect</code>) which can be <i>wrap</i> into a <i>monad</i>. By this way, the core library is not specialized to a specific <i>backend</i>.</p><p>However, this specialization is done as soon as we can. So, <code>Tuyau_unix</code>, <code>Tuyau_mirage</code> or <code>Tuyau_caml</code> are different and can not be used together into a same place.</p></header><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <a href="../Sigs/index.html#module-type-S">Sigs.S</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>+'a <a href="module-type-S/index.html#type-s">s</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-s">s</a></span></code></div><div class="spec module-type" id="module-type-F"><a href="#module-type-F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-F/index.html">F</a> = <a href="../Sigs/index.html#module-type-F">Sigs.F</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-F/index.html#type-input">input</a> = <a href="index.html#type-input">input</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-F/index.html#type-output">output</a> = <a href="index.html#type-output">output</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>+'a <a href="module-type-F/index.html#type-s">s</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-s">s</a></span></code></div><dl><dt class="spec type" id="type-service"><a href="#type-service" class="anchor"></a><code><span class="keyword">type</span> <span>('edn, 't, 'flow) service</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-endpoint">endpoint</a> = <span class="type-var">'edn</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-flow">flow</a> = <span class="type-var">'flow</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> = <span class="type-var">'t</span>)</span></code></dt><dt class="spec type" id="type-protocol"><a href="#type-protocol" class="anchor"></a><code><span class="keyword">type</span> <span>('edn, 'flow) protocol</span></code><code> = <span>(<span class="keyword">module</span> <a href="module-type-F/index.html">F</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-F/index.html#type-endpoint">endpoint</a> = <span class="type-var">'edn</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-F/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span></code></dt></dl><div class="spec module-type" id="module-type-FLOW"><a href="#module-type-FLOW" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html">FLOW</a> = <a href="../Sigs/index.html#module-type-FLOW">Sigs.FLOW</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-input">input</a> = <a href="index.html#type-input">input</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-output">output</a> = <a href="index.html#type-output">output</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>+'a <a href="module-type-FLOW/index.html#type-s">s</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-s">s</a></span></code></div><dl><dt class="spec type" id="type-flow"><a href="#type-flow" class="anchor"></a><code><span class="keyword">type</span> flow</code><code> = </code><table class="variant"><tr id="type-flow.Flow" class="anchored"><td class="def constructor"><a href="#type-flow.Flow" class="anchor"></a><code>| </code><code><span class="constructor">Flow</span> : <span class="type-var">'flow</span> * <span>(<span class="keyword">module</span> <a href="module-type-FLOW/index.html">FLOW</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-flow">flow</a></code></td></tr></table></dt><dd><p>A <code>flow</code> is an abstract value <code>'flow</code> and a module <a href="module-type-FLOW/index.html"><code>FLOW</code></a> (parameterized with <code>'flow</code>). The value <code>'flow</code> is already connected to an <i>endpoint</i> and the module <a href="module-type-FLOW/index.html"><code>FLOW</code></a> can not give to the user a way to re-create (re-connect) the flow. However, it gives a way to receive and send <i>payload</i>:</p><pre><code class="ml">type input = bytes
type output = string

type +'a s = 'a

let process (Flow (flow, (module Flow))) =
  let buf = Bytes.create 0x1000 in
  match Flow.recv flow buf 0 0x1000 with
  | Ok (`Data len) -&gt;
    let str = Bytes.sub_string buf 0 len in
    ignore (Flow.send flow str 0 len)
  | _ -&gt; failwith &quot;Flow.recv&quot;</code></pre></dd></dl><div class="spec module-type" id="module-type-RESOLVER"><a href="#module-type-RESOLVER" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-RESOLVER/index.html">RESOLVER</a> = <a href="../Sigs/index.html#module-type-RESOLVER">Sigs.RESOLVER</a> <span class="keyword">with</span> <span class="keyword">type</span> <span>+'a <a href="module-type-RESOLVER/index.html#type-s">s</a></span> = <span><span class="type-var">'a</span> <a href="index.html#type-s">s</a></span></code></div><dl><dt class="spec type" id="type-resolver"><a href="#type-resolver" class="anchor"></a><code><span class="keyword">type</span> <span>'edn resolver</span></code><code> = <span><span>[ `host ]</span> Domain_name.t</span> <span>&#45;&gt;</span> <span><span><span class="type-var">'edn</span> option</span> <a href="index.html#type-s">s</a></span></code></dt><dd><p>A <code>resolver</code> is an abstract function which resolves a given <code>[ `host ]
     Domain_name.t</code> to an <i>endpoint</i>. At least, it can be implemented as a DNS resolver such as:</p><pre><code class="ml">type +'a s = 'a

let http_resolver : Unix.sockaddr resolver = fun domain_name -&gt;
  match Unix.gethostbyname (Domain_name.to_string domain_name) with
  | { Unix.h_addr_list; _ } -&gt;
    if Array.length h_addr_list &gt; 0
    then Some (Unix.ADDR_INET (h_addr_list.(0), 80))
    else None
  | _ -&gt; None</code></pre><p>Definition of <i>endpoint</i> is free as long as a protocol can initialize/connect a <a href="module-type-FLOW/index.html#type-flow"><code>FLOW.flow</code></a> from it. In our example, a <code>Unix</code> TCP service should exist with <code>Unix.connect</code>.</p></dd></dl><dl><dt class="spec type" id="type-key"><a href="#type-key" class="anchor"></a><code><span class="keyword">type</span> <span>'edn key</span></code></dt><dd><p>To be able to <i>plug</i> a <a href="index.html#type-resolver"><code>resolver</code></a> to a <a href="index.html#type-service"><code>service</code></a> or a <a href="index.html#type-protocol"><code>protocol</code></a>, a value <code>'edn key</code> exists. It represents, at the resolution step, <a href="index.html#type-protocol"><code>protocol</code></a> into an user-defined <a href="Map/index.html#type-t"><code>Map.t</code></a>.</p><p>Any construction of a <a href="index.html#type-service"><code>service</code></a> or a <a href="index.html#type-protocol"><code>protocol</code></a> give to us a <code>'edn key</code> like a <code>Unix.sockaddr key</code> for example. The user has the ability to construct then a restrained way to resolve a <code>[ `host ] Domain_name.t</code>: a set of <i>heterogeneous</i> constructors of <i>endpoint</i>.</p><p>Each constructor of <i>endpoint</i> is bound with a <code>'edn key</code>. If one of them is able to resolve the given domain-name, by the <code>'edn key</code>, <code>Tuyau</code> is able to invoke the right <a href="index.html#type-protocol"><code>protocol</code></a> to process the initialization.</p><pre><code class="ml">val tcp_protocol : (Unix.sockaddr, Unix.file_descr) protocol
val tcp_endpoint : Unix.sockaddr key

val http_resolver : Unix.sockaddr resolver (* on [*:80] *)
val debug_http_resolver : Unix.sockaddr resolver (* on [*:8080] *)

let map =
  Map.empty
  |&gt; register_resolver ~key:tcp_endpoint ~priority:10 http_resolver
  |&gt; register_resolver ~key:tcp_endpoint ~priority:20 debug_http_resolver</code></pre></dd></dl><div class="spec module" id="module-Witness"><a href="#module-Witness" class="anchor"></a><code><span class="keyword">module</span> <a href="Witness/index.html">Witness</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><div class="spec module" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span class="keyword">module</span> <a href="Map/index.html">Map</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec value" id="val-key"><a href="#val-key" class="anchor"></a><code><span class="keyword">val</span> key : string <span>&#45;&gt;</span> <span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></code></dt><dd><p><code>key name</code> creates a new key. The returned value can be bound to a <a href="index.html#type-service"><code>service</code></a> with <a href="index.html#val-register_service"><code>register_service</code></a> or a <a href="index.html#type-protocol"><code>protocol</code></a> with <a href="index.html#val-register_protocol"><code>register_protocol</code></a>.</p><p>The goal of the returned value is to plug a <a href="index.html#type-resolver"><code>resolver</code></a> without any knowledge of the the <a href="index.html#type-protocol"><code>protocol</code></a>.</p><pre><code class="ml">type input = bytes
type output = string

type +'a s = 'a

module Tuyau_tcp : sig
  val key : Unix.sockaddr key
end = struct
  let key : Unix.sockaddr key = key &quot;sockaddr&quot;
  let protocol = register_protocol ~key ~protocol:(module TCP)
end

let resolvers =
  Map.empty
  |&gt; register_resolver ~key:Tuyau_tcp.key http_resolver
  |&gt; register_resolver ~key:Tuyau_tcp_tls.key https_resolver

let mirage_io =
  Domain_name.(host_exn &lt;.&gt; of_string_exn) &quot;mirage.io&quot;

let () =
  match flow resolves mirage_io with
  | Ok (flow, (module Flow)) -&gt;
    ignore (Flow.send flow &quot;Hello World!&quot;)
  | Error err -&gt; failwithf &quot;%a&quot; pp_error err</code></pre></dd></dl><dl><dt class="spec value" id="val-name_of_key"><a href="#val-name_of_key" class="anchor"></a><code><span class="keyword">val</span> name_of_key : <span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span> <span>&#45;&gt;</span> string</code></dt></dl></section><section><header><h4 id="registration."><a href="#registration." class="anchor"></a>Registration.</h4></header><dl><dt class="spec value" id="val-register_service"><a href="#val-register_service" class="anchor"></a><code><span class="keyword">val</span> register_service : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span>service:<span><span>(<span class="type-var">'edn</span>,Â <span class="type-var">'t</span>,Â <span class="type-var">'flow</span>)</span> <a href="index.html#type-service">service</a></span></span> <span>&#45;&gt;</span> <span>protocol:<span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span> * <span class="type-var">'flow</span>)</span> <a href="Witness/index.html#type-service">Witness.service</a></span></code></dt><dd><p><code>register_service ~key ~service ~protocol</code> registers implementation of a <i>service</i> which is able to make a <i>flow</i> (an established transmission between the service and an entity) according to the given definition <code>protocol</code>. It binds <code>service</code> with <code>key</code> to be able to correctly initialize the given service.</p><p>A <a href="index.html#type-service"><code>service</code></a> is not use with the resolution process because we assert that the initialization of any service should be fully know. <code>key</code> unlocks only the ability to let the user to define his type of <i>endpoint</i>/<i>configuration</i> - at this stage, and only about <a href="index.html#type-service"><code>service</code></a>, goal of <code>key</code> differs from <a href="index.html#val-register_protocol"><code>register_protocol</code></a>.</p><pre><code class="ml">module TCP_service : S with type configuration = Unix.sockaddr
                        and type t = Unix.file_descr
                        and type flow = TCP.t (* = Unix.file_descr *)

let key : Unix.sockaddr = key &quot;sockaddr&quot;
let service : (Unix.file_descr * TCP.t) Witness.service =
  register_service ~key ~service:(module TCP_service) ~protocol:TCP.protocol</code></pre></dd></dl><dl><dt class="spec value" id="val-register_protocol"><a href="#val-register_protocol" class="anchor"></a><code><span class="keyword">val</span> register_protocol : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span>protocol:<span><span>(<span class="type-var">'edn</span>,Â <span class="type-var">'flow</span>)</span> <a href="index.html#type-protocol">protocol</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span></code></dt><dd><p><code>register_protocol ~key ~protocol</code> registers implementation of a <i>protocol</i> and binds it with <code>key</code> - any resolver bound into a <a href="Map/index.html#type-t"><code>Map.t</code></a> with this <code>key</code> will call (at least) <code>connect</code> given by <code>protocol</code>.</p><p><code>protocol</code> is an OCaml module which respects the interface <a href="module-type-F/index.html"><code>F</code></a> (a specialization of <a href="module-type-FLOW/index.html"><code>FLOW</code></a> according <a href="index.html#type-input"><code>input</code></a>, <a href="index.html#type-output"><code>output</code></a> and <a href="index.html#type-s"><code>s</code></a>).</p><p>The returned value is a <i>light</i> representation of the given <code>protocol</code> which can be use by the user for some others processes like the composition.</p><pre><code class="ml">module TCP : F with type endpoint = Unix.sockaddr
                and type t = Unix.file_descr

let key : Unix.sockaddr key = key &quot;sockaddr&quot;
let protocol : Unix.file_descr Witness.protocol =
  register_protocol ~key ~protocol:(module TCP)</code></pre></dd></dl><dl><dt class="spec value" id="val-register_resolver"><a href="#val-register_resolver" class="anchor"></a><code><span class="keyword">val</span> register_resolver : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;priority:int</span> <span>&#45;&gt;</span> <span><span class="type-var">'edn</span> <a href="index.html#type-resolver">resolver</a></span> <span>&#45;&gt;</span> <a href="Map/index.html#type-t">Map.t</a> <span>&#45;&gt;</span> <a href="Map/index.html#type-t">Map.t</a></code></dt><dd><p><code>register_resolver ~key ?priority resolver m</code> adds a new <code>resolver</code> into <code>m</code>. <code>resolver</code> is bound to <code>key</code>. From a set of <code>key</code> which represent the way to initialize a <a href="index.html#type-protocol"><code>protocol</code></a>, we can bind a <code>resolver</code> into <code>m</code>.</p><p>When the <code>resolver</code> is able to resolve the given domain-name, it will try to initialize the transmission over the protocol bound to the shared <code>key</code>. We try resolvers to a specific order (lower to higher).</p><pre><code class="ml">val resolver_on_my_private_network : Unix.sockaddr resolver
val resolver_on_internet : Unix.sockaddr resolver

let m =
  Map.empty
  |&gt; register_resolver ~key:tcp_endpoint ~priority:10 resolver_on_my_private_network
  |&gt; register_resolver ~key:tcp_endpoint ~priority:20 resolver_on_internet</code></pre></dd></dl><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code> = <code>[ </code><table class="variant"><tr id="type-error.Msg" class="anchored"><td class="def constructor"><a href="#type-error.Msg" class="anchor"></a><code>| </code><code>`Msg <span class="keyword">of</span> string</code></td></tr><tr id="type-error.Not_found" class="anchored"><td class="def constructor"><a href="#type-error.Not_found" class="anchor"></a><code>| </code><code>`Not_found</code></td></tr><tr id="type-error.Invalid_key" class="anchored"><td class="def constructor"><a href="#type-error.Invalid_key" class="anchor"></a><code>| </code><code>`Invalid_key</code></td></tr><tr id="type-error.Unresolved" class="anchored"><td class="def constructor"><a href="#type-error.Unresolved" class="anchor"></a><code>| </code><code>`Unresolved</code></td></tr></table><code> ]</code></dt></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <span><a href="index.html#type-error">error</a> Fmt.t</span></code></dt><dt class="spec value" id="val-abstract"><a href="#val-abstract" class="anchor"></a><code><span class="keyword">val</span> abstract : <span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span> <span>&#45;&gt;</span> <span class="type-var">'flow</span> <span>&#45;&gt;</span> <a href="index.html#type-flow">flow</a></code></dt><dd><p><code>abstract protocol flow</code> constructs an abstracted value <a href="index.html#type-flow"><code>flow</code></a> from a representation of the implementation of the protocol (<code>protocol</code>) and an already initialized <code>flow</code>.</p></dd></dl><dl><dt class="spec value" id="val-flow_of_endpoint"><a href="#val-flow_of_endpoint" class="anchor"></a><code><span class="keyword">val</span> flow_of_endpoint : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'edn</span> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-flow">flow</a>,Â <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-s">s</a></span></code></dt><dd><p><code>flow_of_endpoint ~key edn</code> creates a new abstracted flow from the given endpoint <code>'edn</code>. Protocol used to initialize the transmission is (already) registered with <a href="index.html#val-register_protocol"><code>register_protocol</code></a> and <code>key</code>.</p><p>User can register more than one protocol with the given <code>key</code>. In this case, all of these protocols are extracted and they try to initialize the transmission. The first which initializes the transmission is taken to return the <a href="index.html#type-flow"><code>flow</code></a>. The order of protocols is undefined.</p><pre><code class="ml">let sockaddr : Unix.sockaddr = Tuyau.key &quot;sockaddr&quot;
let tcp : Unix.file_descr Witness.protocol
let udp : Unix.file_descr Witness.protocol

let mirage_io : Unix.sockaddr = match Unix.gethostbyname &quot;mirage.io&quot; with
  | { Unix.h_addr_list; _ } -&gt;
    if Array.length h_addr_list &gt; 0
    then Unix.ADDR_INET (h_addr_list.(0), 4242)
    else failwith &quot;Impossible to resolver mirage.io&quot;

let () = match flow_of_endpoint ~key:sockaddr mirage_io with
  | Ok (flow, (module Flow)) -&gt;
    ignore (Flow.send flow &quot;Hello World!&quot;)
  | Error err -&gt; failwithf &quot;%a&quot; pp_error err</code></pre></dd></dl><dl><dt class="spec value" id="val-flow_of_protocol"><a href="#val-flow_of_protocol" class="anchor"></a><code><span class="keyword">val</span> flow_of_protocol : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'edn</span> <span>&#45;&gt;</span> <span>protocol:<span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'flow</span>,Â <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-s">s</a></span></code></dt><dd><p><code>flow_of_protocol ~key edn ~protocol</code> creates a new concrete <code>'flow</code> from the given endpoint <code>'edn</code>. Protocol used to initialize the transmission is (and only is) <code>protocol</code>.</p><pre><code class="ml">let sockaddr : Unix.sockaddr = Tuyau.key &quot;sockaddr&quot;
let tcp : Unix.file_descr Witness.protocol

let mirage_io : Unix.sockaddr = match Unix.gethostbyname &quot;mirage.io&quot; with
  | { Unix.h_addr_list; _ } -&gt;
    if Array.length h_addr_list &gt; 0
    then Unix.ADDR_INET (h_addr_list.(0), 4242)
    else failwith &quot;Impossible to resolver mirage.io&quot;

let () = match flow_of_protocol ~key:sockaddr ~protocol:tcp mirage_io with
  | Ok fd -&gt;
    ignore (Unix.write fd &quot;Hello World!&quot; 0 12)
  | Error err -&gt; failwithf &quot;%a&quot; pp_error err</code></pre></dd></dl></section><section><header><h4 id="tuyau-as-a-client."><a href="#tuyau-as-a-client." class="anchor"></a><code>Tuyau</code> as a client.</h4></header><dl><dt class="spec value" id="val-flow"><a href="#val-flow" class="anchor"></a><code><span class="keyword">val</span> flow : <a href="Map/index.html#type-t">Map.t</a> <span>&#45;&gt;</span> <span>?&#8288;key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span>?&#8288;protocol:<span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span></span> <span>&#45;&gt;</span> <span><span>[ `host ]</span> Domain_name.t</span> <span>&#45;&gt;</span> <span><span><span>(<a href="index.html#type-flow">flow</a>,Â <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-s">s</a></span></code></dt><dd><p><code>flow resolvers domain_name</code> tries to create a new abstracted according to <code>resolvers</code>. Each resolver tries to resolve the given domain-name (they are ordered by the given priority). Then, from a <i>heterogeneous</i> set of <i>endpoints</i>, we try to initialize/establish a transmission. The first which initializes the connection is taken to return the <a href="index.html#type-flow"><code>flow</code></a>.</p><p>User can enforce to use a specific <code>key</code> and, by this way, a specific resolver instead to call all of them (available into <code>resolvers</code>).</p><p>User can enforce to use a specific <code>protocol</code>, and by this way, enforce to use a specific <code>key</code> (which is bound by <code>protocol</code>).</p><pre><code class="ml">let mirage_io = Domain_name.(host_exn &lt;.&gt; of_string_exn) &quot;mirage.io&quot;

val resolver_on_my_private_network : Unix.sockaddr resolver
val resolver_on_internet : Unix.sockaddr resolver
val resolver_with_tls : Tls.Config.client -&gt; Unix.sockaddr resolver

let resolvers =
  Map.empty
  |&gt; register_resolver ~key:tls_endpoint ~priority:0 (resolver_with_tls tls_config)
  |&gt; register_resolver ~key:tcp_endpoint ~priority:10 resolver_on_my_private_network
  |&gt; register_resolver ~key:tcp_endpoint ~priority:20 resolver_on_internet

let () = match flow resolvers mirage_io with
  | Ok (flow, (module Flow)) -&gt;
    ignore (Flow.send flow &quot;Hello World!&quot;)
  | Error err -&gt; failwithf &quot;%a&quot; pp_error err</code></pre></dd></dl></section><section><header><h4 id="tuyau-as-a-server."><a href="#tuyau-as-a-server." class="anchor"></a><code>Tuyau</code> as a server.</h4></header><dl><dt class="spec value" id="val-serve"><a href="#val-serve" class="anchor"></a><code><span class="keyword">val</span> serve : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span class="type-var">'edn</span> <span>&#45;&gt;</span> <span>service:<span><span>(<span class="type-var">'t</span> * <span class="type-var">'flow</span>)</span> <a href="Witness/index.html#type-service">Witness.service</a></span></span> <span>&#45;&gt;</span> <span><span><span>(<span class="type-var">'t</span> * <span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span>,Â <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span> <a href="index.html#type-s">s</a></span></code></dt><dd><p><code>serve ~key edn ~service</code> creates a new <i>master</i> server with which <i>protocol</i> it can deliver according a configuration <code>'edn</code>. <code>serve</code> is more restrictive than <a href="index.html#type-flow"><code>flow</code></a> when we assert that the initialization of a service should be fully know.</p><p>The initialization of the service returns a concrete type <code>'t</code> which represents the service. It returns which protocol is used to transmit information with entities.</p><pre><code class="ml">val sockaddr : Unix.sockaddr key
val tcp_service : (Unix.file_descr * TCP.t) Witness.service

let () =
  impl_of_service ~key:sockaddr tcp_service |&gt; get_ok |&gt; fun (module Server) -&gt;
  match serve ~key:sockaddr Unix.(ADDR_INET (inet_addr_any, 8080)) tcp_service with
  | Ok (master, protocol) -&gt;
    let module Flow = impl_of_flow protocol in
    let rec go () = match Server.accept t with
      | Ok flow -&gt;
        ignore (Flow.send flow &quot;Hello World&quot;) ;
        Flow.close flow ;
        go ()
      | Error err -&gt; failwithf &quot;%a&quot; Server.pp_error err in
    go ()</code></pre></dd></dl><dl><dt class="spec value" id="val-impl_of_service"><a href="#val-impl_of_service" class="anchor"></a><code><span class="keyword">val</span> impl_of_service : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span><span>(<span class="type-var">'t</span> * <span class="type-var">'flow</span>)</span> <a href="Witness/index.html#type-service">Witness.service</a></span> <span>&#45;&gt;</span> <span><span>(<span>(<span class="keyword">module</span> <a href="module-type-S/index.html">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-endpoint">endpoint</a> = <span class="type-var">'edn</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-flow">flow</a> = <span class="type-var">'flow</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-S/index.html#type-t">t</a> = <span class="type-var">'t</span>)</span>,Â <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dt class="spec value" id="val-impl_of_protocol"><a href="#val-impl_of_protocol" class="anchor"></a><code><span class="keyword">val</span> impl_of_protocol : <span>key:<span><span class="type-var">'edn</span> <a href="index.html#type-key">key</a></span></span> <span>&#45;&gt;</span> <span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span> <span>&#45;&gt;</span> <span><span>(<span>(<span class="keyword">module</span> <a href="module-type-F/index.html">F</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-F/index.html#type-endpoint">endpoint</a> = <span class="type-var">'edn</span> <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-F/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span>,Â <span>[&gt; <a href="index.html#type-error">error</a> ]</span>)</span> Stdlib.result</span></code></dt><dt class="spec value" id="val-impl_of_flow"><a href="#val-impl_of_flow" class="anchor"></a><code><span class="keyword">val</span> impl_of_flow : <span><span class="type-var">'flow</span> <a href="Witness/index.html#type-protocol">Witness.protocol</a></span> <span>&#45;&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-FLOW/index.html">FLOW</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-FLOW/index.html#type-flow">flow</a> = <span class="type-var">'flow</span>)</span></code></dt></dl></section></div></body></html>