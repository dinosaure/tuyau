<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tuyau (tuyau.Tuyau)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">tuyau</a> &#x00BB; Tuyau</nav><h1>Module <code>Tuyau</code></h1><nav class="toc"><ul><li><a href="#a-protocol.">A Protocol.</a></li><li><a href="#a-flow.">A Flow.</a></li><li><a href="#resolution.">Resolution.</a></li><li><a href="#conclusion.">Conclusion.</a></li><li><a href="#composition.">Composition.</a></li></ul></nav></header><div class="spec module" id="module-Sigs"><a href="#module-Sigs" class="anchor"></a><code><span class="keyword">module</span> <a href="Sigs/index.html">Sigs</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><aside><p><code>Tuyau</code> is a little library which wants to give to the developer the easiest way to compose protocols and only one way to make a <i>Flow</i>. Several words are used in this sentence and we need a clear definition of them to fully understand the purpose of <code>Tuyau</code>.</p></aside><section><header><h4 id="a-protocol."><a href="#a-protocol." class="anchor"></a>A Protocol.</h4><p>A communication protocol is a system of rules that allows entities to transmit information. In the case of <code>Tuyau</code>, this kind of information must not be arbitrary. The protocol should only solve communication problems such as <i>routing</i>.</p><p>When we talk about a protocol, it's only about a standard which is able to transmit a <i>payload</i>. Interpretation of the <i>payload</i> is not done by the <i>protocol</i> but by the user of this library.</p><p>For example, the Transmission Control Protocol (TCP) <b>is</b> a protocol according to <code>Tuyau</code> because it is able to transmit <i>payload</i> without interpreting it. A counter example is the Simple Mail Transfer Protocol (SMTP) which gives an interpretation of the <i>payload</i> (such as <code>EHLO</code> which is different to <code>QUIT</code>).</p><p>This difference is important to unlock the ability to compose <i>protocols</i>. An other protocol according to <code>Tuyau</code> is Transport Layer Security (TLS) - which wants to solve privacy and data integrity. <code>Tuyau</code> is able to compose protocols together like <code>TCP ∘ TLS</code> to make a new protocol. From this composition, the user is able to implement Secure Simple Mail Transfer Protocol (SSMTP) or HyperText Transfer Protocol Secure (HTTPS) - both use TCP and TLS.</p></header></section><section><header><h4 id="a-flow."><a href="#a-flow." class="anchor"></a>A Flow.</h4><p>To be able to do this composition, the protocol must respect an interface: the <code>FLOW</code> interface. It defines an abstract type <code>t</code> and functions like <code>recv</code> or <code>send</code>. These functions give to us the <i>payload</i>. Rules to solve communication problems are already processed internally.</p><p>In other terms, from a given <code>FLOW</code>, the user should not handle <i>routing</i>, privacy or data integrity (or some others problems). The user should only be able to process the <i>payload</i>.</p><p>Finally, representation of a TCP protocol is a <code>FLOW</code>. VCHAN protocol or User Datagram Protocol (UDP) can be represented by a <code>FLOW</code>. However, TLS is not a flow but a layer on top of another protocol. Composition with it should look like:</p><pre><code class="ml">val with_tls : (module FLOW) -&gt; (module FLOW) </code></pre><p>From a given <code>FLOW</code>, we <i>wrap</i> it with TLS and return a new <code>FLOW</code>. Such a composition exists also for WireGuard or Noise layers. <code>Tuyau</code> wants to solve this composition by a strict OCaml interface of the <code>FLOW</code>.</p></header></section><section><header><h4 id="resolution."><a href="#resolution." class="anchor"></a>Resolution.</h4><p><code>Tuyau</code> wants to solve one last problem, resolution of an <i>endpoint</i>. The goal is to make a <code>FLOW</code> from an <i>endpoint</i> given by the developer.</p><p>Definition of an endpoint can not fully exist where it depends on the returned <code>FLOW</code>. For example, if we give to you a TCP flow, <i>endpoint</i> should be an IP and a <i>port</i> where the given <code>FLOW</code> is <b>already</b> connected.</p><p>However, we agree that the most general (by convention) description of the <i>endpoint</i> is the domain-name. By knowing this, we let the developer to construct an <i>endpoint</i> from a <code>[ `host ] Domain_name.t</code>.</p><p>At the end, <code>Tuyau</code> should be able to construct an <i>endpoint</i> from a <code>[
   `host ] Domain_name.t</code>. Then, it tries to find a <code>SERVICE</code> according to the given <i>endpoint</i> and initializes a <code>FLOW</code>.</p><p>The most abstract definition provided by <code>Tuyau</code> is:</p><pre><code class="ml">val flow : resolvers -&gt; [ `host ] Domain_name.t -&gt; flow </code></pre><p>Where <code>resolvers</code> is a set of <i>heterogeneous</i> constructors of <i>endpoints</i> given by the developer. The returned value <code>flow</code> is an abstraction of an <b>already</b> initialized communication protocol. From it, the developer can <i>extract</i> <code>send</code> and <code>recv</code> functions (as described into <code>A Protocol</code>).</p></header></section><section><header><h4 id="conclusion."><a href="#conclusion." class="anchor"></a>Conclusion.</h4><p><code>Tuyau</code> is a <i>framework</i> which wants to give a few definitions to <b>restrict</b> developers of protocols to an interface <code>FLOW</code> and, by this way, provide them with a set of tools to compose with others protocols and give only one way to resolve an <i>endpoint</i> (whatever its definition).</p><p><code>Tuyau</code> does not make magic and all described processes previously are explicit - composition, resolution, extraction. This last aspect wants to solve a well-known problem of <code>Conduit</code> where nobody can fully understand this framework.</p><p>You can start to read the rest of the documentation.</p></header><div class="spec module-type" id="module-type-S"><a href="#module-type-S" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-S/index.html">S</a> = <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h4 id="composition."><a href="#composition." class="anchor"></a>Composition.</h4><p><code>Tuyau</code> does not do something magic as we said into the introduction. Composition of protocols must be done by <i>protocol</i> developer. <code>Tuyau</code> gives interfaces which can be help this composition - but <i>the glue</i> needed must be implemented.</p><p>Considering TLS as a layer which can compose with an other protocol, the implementation looks like:</p><pre><code class="ml">type input
type output
type +'a s

type 'flow with_tls =
  { flow : 'flow
  ; tls : Tls.Engine.state }

module With_tls
    (Flow : Sigs.F with type input = input
                    and type output = output
                    and type +'a s = 'a s)
= struct
  type flow = Flow.flow with_tls
  type endpoint = Flow.endpoint * Tls.Config.client

  ...
end

let with_tls
  :  type edn flow.
     key:edn key
  -&gt; flow Witness.protocol
  -&gt; (edn * Tls.Config.client) key * flow with_tls Witness.protocol
  = fun ~key protocol -&gt;
    match impl_of_protocol ~key protocol with
    | Ok (module Flow) -&gt;
      let module M = With_tls(Flow) in
      let k = key &quot;with_tls&quot; in
      let p = register_protocol ~key:k ~protocol:(module M) in
      k, p
    | Error err -&gt; failwithf &quot;%a&quot; pp_error err</code></pre></header><div class="spec module" id="module-Make"><a href="#module-Make" class="anchor"></a><code><span class="keyword">module</span> <a href="Make/index.html">Make</a> : <span class="keyword">functor</span> (<a href="Make/argument-1-Scheduler/index.html">Scheduler</a> : <a href="Sigs/index.html#module-type-SCHEDULER">Sigs.SCHEDULER</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-2-Input/index.html">Input</a> : <a href="Sigs/index.html#module-type-SINGLETON">Sigs.SINGLETON</a>) <span>&#45;&gt;</span> <span class="keyword">functor</span> (<a href="Make/argument-3-Output/index.html">Output</a> : <a href="Sigs/index.html#module-type-SINGLETON">Sigs.SINGLETON</a>) <span>&#45;&gt;</span> <a href="index.html#module-type-S">S</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="Make/index.html#type-input">input</a> = <a href="Make/argument-2-Input/index.html#type-t">Input.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <a href="Make/index.html#type-output">output</a> = <a href="Make/argument-3-Output/index.html#type-t">Output.t</a> <span class="keyword">and</span> <span class="keyword">type</span> <span>+'a <a href="Make/index.html#type-s">s</a></span> = <span><span class="type-var">'a</span> <a href="Make/argument-1-Scheduler/index.html#type-t">Scheduler.t</a></span></code></div></section></div></body></html>